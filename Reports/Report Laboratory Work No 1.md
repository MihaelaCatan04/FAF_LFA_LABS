# Laboratory Work Report
## Formal Languages & Finite Automata

**Topic:** Intro to formal languages. Regular grammars. Finite Automata.  
**Course:** Formal Languages & Finite Automata  
**Author:** Mihaela Catan, st.gr.FAF-231
**Verified by:** Dumitru Crețu, university Assistant 
**Date:** February 16, 2025

## Introduction

In computer science, formal languages serve as the foundation for communication between machines and humans. This laboratory work explores the fundamental concepts of formal languages, regular grammars, and finite automata, with a focus on their implementation in Python.

A formal language comprises several essential components:
- **Alphabet:** A set of valid characters
- **Vocabulary:** A set of valid words
- **Grammar:** A set of rules and constraints governing the language

## Theoretical Background

### Formal Languages

A formal language is a set of strings of symbols that are constructed according to specific rules, known as a grammar. These languages are used in mathematics, computer science, linguistics, and other fields to formally define structures for study.

More formally, a formal language is defined over an alphabet Σ as a subset of Σ*, where Σ* represents the set of all possible strings that can be formed by concatenating symbols from Σ. For example, if Σ = {0, 1}, then Σ* includes ε (the empty string), 0, 1, 00, 01, 10, 11, 000, etc.

### Formal Grammars

A formal grammar is a set of production rules that describe how to form valid strings in a language. Formally, a grammar G is defined as a quadruple (N, T, P, S), where:
- N is a set of non-terminal symbols
- T is a set of terminal symbols
- P is a set of production rules
- S is the start symbol (S ∈ N)

The production rules in P have the form α → β, where α and β are strings of symbols from (N ∪ T), and α contains at least one symbol from N.

#### Chomsky Hierarchy

Noam Chomsky introduced a hierarchy of grammars, categorizing them into four types:

1. **Type 0 (Unrestricted)**: No restrictions on production rules. These grammars generate recursively enumerable languages.
2. **Type 1 (Context-sensitive)**: Production rules of the form αAβ → αγβ, where A is a non-terminal and γ is a non-empty string.
3. **Type 2 (Context-free)**: Production rules of the form A → γ, where A is a non-terminal.
4. **Type 3 (Regular)**: Production rules of the form A → a or A → aB, where A and B are non-terminals and a is a terminal.

Regular grammars (Type 3) are the most restricted form and can be represented by finite automata.

### Regular Grammars

Regular grammars are a subset of formal grammars that generate regular languages. They come in two varieties:

1. **Right Regular Grammar**: Productions are of the form A → a or A → aB, where A and B are non-terminals and a is a terminal.
2. **Left Regular Grammar**: Productions are of the form A → a or A → Ba, where A and B are non-terminals and a is a terminal.

Regular grammars have the important property that they can be directly converted to finite automata and vice versa.

### Finite Automata

A finite automaton (FA) is a mathematical model of computation with finite internal memory. It reads input symbols one by one and changes its internal state based on the current state and the input symbol.

Formally, a finite automaton is a 5-tuple (Q, Σ, δ, q₀, F), where:
- Q is a finite set of states
- Σ is the input alphabet
- δ is the transition function (δ: Q × Σ → Q for deterministic FA, or δ: Q × Σ → P(Q) for non-deterministic FA, where P(Q) is the power set of Q)
- q₀ is the initial state (q₀ ∈ Q)
- F is the set of final or accepting states (F ⊆ Q)

#### Types of Finite Automata

1. **Deterministic Finite Automaton (DFA)**: For each state and input symbol, there is exactly one transition to another state.
2. **Non-deterministic Finite Automaton (NFA)**: A state can have multiple transitions for the same input symbol or ε-transitions (transitions without consuming any input).

Both DFA and NFA have the same expressive power—they recognize the same class of languages (regular languages).

### Equivalence of Regular Grammars and Finite Automata

There is a fundamental equivalence between regular grammars and finite automata:

1. Any language generated by a regular grammar can be recognized by a finite automaton.
2. Any language recognized by a finite automaton can be generated by a regular grammar.

This equivalence is the foundation for many algorithms in compiler design, text processing, and pattern matching.

## Objectives

This laboratory work aims to achieve the following objectives:

1. Understand the concept of formal languages and their requirements
2. Set up a project environment for ongoing work throughout the semester
3. Implement a `Grammar` class capable of:
   - Generating valid strings from a defined grammar
   - Converting itself to a Finite Automaton
4. Implement a `FiniteAutomaton` class with string validation capabilities

## Implementation

### Project Setup

The `Grammar` class represents a formal grammar with the following components:
- Non-terminal symbols (`non_terminals`)
- Terminal symbols (`terminals`)
- Production rules (`productions`)
- Start symbol (`start_symbol`)

```python
class Grammar:
    def __init__(self, non_terminals, terminals, productions, start_symbol):
        self.non_terminals = non_terminals
        self.terminals = terminals
        self.productions = productions
        self.start_symbols = start_symbol

    # Method to generate a string
    def generate_string(self):
        # Randomly select an initial production from the start symbol's productions
        result = random.choice(self.productions[self.start_symbols])
        # Continue generating the string until there are no non-terminals left in the result
        while any(non_terminal in result for non_terminal in self.non_terminals):
            # Initialize a new string to hold the final result
            final_result = ""
            # Iterate over each character in the current result
            for letter in result:
                if letter in self.non_terminals:
                    # If the character is a non-terminal, replace it with a random production for that non-terminal
                    final_result += random.choice(self.productions[letter])
                else:
                    # If the character is a terminal, keep it unchanged
                    final_result += letter
            # Update the result with the newly expanded string
            result = final_result
        return result

    # Method to generate a list of strings
    def generate_strings(self, number_of_strings):
        strings = []
        for _ in range(number_of_strings):
            strings.append(self.generate_string())
        return strings
```

#### Method Analysis: `__init__`

The constructor initializes the grammar with its four essential components:
1. `non_terminals`: A set of non-terminal symbols that can be replaced by production rules
2. `terminals`: A set of terminal symbols that form the actual strings of the language
3. `productions`: A dictionary mapping non-terminal symbols to their possible productions
4. `start_symbol`: The non-terminal symbol from which string generation begins

This initialization follows the formal definition of a grammar as G = (N, T, P, S), where:
- N = `non_terminals`
- T = `terminals`
- P = `productions`
- S = `start_symbol`

#### Method Analysis: `generate_string`

This method implements a stochastic context-free grammar (SCFG) string generation algorithm:

1. It begins by selecting a random production for the start symbol
2. It then iteratively replaces non-terminal symbols with their productions until no non-terminals remain
3. For each non-terminal encountered, it makes a random choice among its possible productions

The algorithm uses a breadth-first approach to symbol replacement, processing all symbols in the current string before moving to the next iteration. This ensures that the generation process terminates, assuming the grammar doesn't contain any non-terminating production rules (such as A → A).

Time complexity: O(n × m), where n is the length of the final string and m is the maximum number of iterations needed to eliminate all non-terminals.

#### Method Analysis: `generate_strings`

This is a utility method that simply calls `generate_string()` multiple times to produce the requested number of strings. It encapsulates the repetitive task of generating multiple strings, improving the API's usability.

Time complexity: O(k × n × m), where k is the number of strings to generate, n is the average length of each generated string, and m is the average number of iterations needed to eliminate all non-terminals.

### Finite Automaton Implementation

The `FiniteAutomaton` class represents a deterministic finite automaton with the following components:
- States (`states`)
- Alphabet (`alphabet`)
- Transition function (`transitions`)
- Start state (`start_state`)
- Final states (`final_states`)

```python
class FiniteAutomaton:
    def __init__(self, grammar):
        self.states = grammar.non_terminals.union({"F"})
        self.alphabet = grammar.terminals
        self.transitions = {state: {} for state in self.states}
        self.start_state = grammar.start_symbol
        self.final_states = {"F"}
        self.__build_transitions(grammar)

    # Method for creating transitions from productions
    def __build_transitions(self, grammar):
        # Iterate over each non-terminal and its corresponding list of productions
        for non_terminal, production_list in grammar.productions.items():
            # For each production, iterate through its symbols to identify terminals and handle transitions
            for production in production_list:
                current_state = non_terminal
                for symbol in production:
                    if symbol in grammar.terminals:
                        # Create or update transitions for each terminal symbol in the production
                        if symbol not in self.transitions[current_state]:
                            # Initialize the list for the terminal symbol if it does not already have any transitions
                            self.transitions[current_state][symbol] = []
                        # Determine the resulting state by removing the current terminal from the production
                        # If the result is empty, transition to the final state 'F'
                        result = "".join([c for c in production if c != symbol])
                        self.transitions[current_state][symbol].append(result if result != "" else "F")

    # Method do display the transitions
    def display_transitions(self):
        print("Finite Automaton Transitions:")
        print(self.transitions)
        for state, transitions in self.transitions.items():
            for symbol, target_states in transitions.items():
                print(f"State {state} --({symbol})--> {target_states}")

    # Method to check if a string can be obtained via the state transition
    def check_string(self, given_input):
        # Initialize a deque to store (state, index) pairs for traversal
        queue = deque([(self.start_state, 0)])
        # Process the queue until all possible paths are explored
        while queue:
            # Dequeue the current state and the current index in the input string
            current_state, index = queue.popleft()
            # Check if the end of the input string has been reached
            if index == len(given_input):
                # Check if the state is in the final states
                if current_state in self.final_states:
                    return True
                # Otherwise, continue exploring other transitions
                continue
            # Get the current symbol from the input string
            symbol = given_input[index]
            # Check if there are transitions from the current state for the given symbol
            if symbol in self.transitions.get(current_state):
                # Enqueue all possible next states along with the incremented index
                for next_state in self.transitions[current_state][symbol]:
                    queue.append((next_state, index + 1))
        # If no valid transition reaches a final state, the string is rejected
        return False
```

#### Method Analysis: `__init__`

The constructor initializes the finite automaton using a grammar object, performing the grammar-to-automaton conversion:

1. It creates a set of states that includes all non-terminals from the grammar plus a special final state 'F'
2. It adopts the grammar's terminal symbols as the automaton's alphabet
3. It initializes an empty transition function for each state
4. It designates the grammar's start symbol as the automaton's start state
5. It defines a singleton set containing 'F' as the automaton's final states
6. It calls `__build_transitions` to construct the transition function based on the grammar's production rules

This initialization follows the formal definition of a finite automaton as A = (Q, Σ, δ, q₀, F), where:
- Q = `states`
- Σ = `alphabet`
- δ = `transitions`
- q₀ = `start_state`
- F = `final_states`

#### Method Analysis: `__build_transitions`

This private method constructs the automaton's transition function from the grammar's production rules:

1. It iterates through each non-terminal and its associated productions
2. For each production, it examines each symbol to identify terminals
3. When it finds a terminal symbol, it:
   - Creates a transition from the current state using the terminal as the input symbol
   - Determines the resulting state by removing the terminal from the production
   - If the result is empty, it transitions to the special final state 'F'

The method essentially implements the standard algorithm for converting a right-linear regular grammar to a finite automaton. The resulting automaton is non-deterministic in general, as multiple transitions may exist for the same state-symbol pair.

Time complexity: O(n × m), where n is the number of non-terminals and m is the average number of symbols in each production.

#### Method Analysis: `display_transitions`

This method provides a human-readable representation of the automaton's transition function:

1. It prints a header indicating that the transitions will be displayed
2. It prints the raw transition structure (useful for debugging)
3. It iterates through each state and its transitions, printing them in a more readable format

This method is primarily for debugging and visualization purposes, helping users understand the automaton's structure.

Time complexity: O(n × m), where n is the number of states and m is the average number of transitions per state.

#### Method Analysis: `check_string`

This method implements a breadth-first search algorithm to determine whether a given string is accepted by the automaton:

1. It initializes a queue with a pair containing the start state and an index of 0 (beginning of the input string)
2. It processes the queue until all possible paths have been explored
3. For each state-index pair, it:
   - Checks if the index has reached the end of the input string
   - If so, verifies whether the current state is a final state
   - If not, processes the next input symbol and all possible transitions
4. If any path leads to a final state after consuming the entire input, the string is accepted
5. Otherwise, the string is rejected

The method effectively simulates the non-deterministic automaton by exploring all possible execution paths in parallel.

Time complexity: O(n × m), where n is the length of the input string and m is the maximum number of possible transitions for a state-symbol pair.

## Testing

### Grammar Tests

The `TestGrammar` class tests the functionality of the `Grammar` class:

```python
class TestGrammar(unittest.TestCase):
    # Set up the test environment
    def setUp(self):
        self.non_terminals = {"S", "I", "J", "K"}
        self.terminals = {"a", "b", "c", "e", "n", "f", "m"}
        self.productions = {
            'S': ['cI'],
            'I': ['bJ', 'fI', 'e', 'eK'],
            'J': ['nJ', 'cS'],
            'K': ['nK', 'm']
        }
        self.start_symbol = "S"
        self.grammar = Grammar(self.non_terminals, self.terminals, self.productions, self.start_symbol)

    # Test case: Check if the generated string contains only terminal symbols
    def test_generate_string_contains_only_terminals(self):
        generated_string = self.grammar.generate_string()
        for char in generated_string:
            self.assertIn(char, self.terminals, f"Non-terminal '{char}' found in generated string.")

    # Test case: Generate multiple strings and check if the correct number is generated
    def test_generate_multiple_strings(self):
        num_strings = 5
        generated_strings = self.grammar.generate_strings(num_strings)
        self.assertEqual(len(generated_strings), num_strings, "Incorrect number of strings generated.")

    # Test case: Check that the generated string is not empty
    def test_generated_strings_are_not_empty(self):
        generated_string = self.grammar.generate_string()
        self.assertTrue(len(generated_string) > 0, "Generated string is empty.")

    # Test case: Ensure that the generated string follows the grammar's productions
    def test_productions_are_followed(self):
        generated_string = self.grammar.generate_string()
        self.assertTrue(all(char in self.terminals for char in generated_string), "Invalid production used.")
```

### Finite Automaton Tests

The `TestFiniteAutomaton` class tests the functionality of the `FiniteAutomaton` class:

```python
class TestFiniteAutomaton(unittest.TestCase):
    # Set up the test environment
    def setUp(self):
        non_terminals = {"S", "I", "J", "K"}
        terminals = {"a", "b", "c", "e", "n", "f", "m"}
        productions = {
            'S': ['cI'],
            'I': ['bJ', 'fI', 'e', 'eK'],
            'J': ['nJ', 'cS'],
            'K': ['nK', 'm']
        }
        start_symbol = "S"
        self.grammar = Grammar(non_terminals, terminals, productions, start_symbol)
        self.finite_automaton = FiniteAutomaton(self.grammar)

    # Test case: Check if the string "cbccfem" is accepted by the finite automaton
    def test_check_valid_string(self):
        result = self.finite_automaton.check_string("cbccfem")
        self.assertTrue(result)

    # Test case: Check if the string "cbccf" is rejected by the finite automaton
    def test_check_invalid_string(self):
        result = self.finite_automaton.check_string("cbccf")
        self.assertFalse(result)

    # Test case: Check if an empty string is rejected by the finite automaton
    def test_empty_string(self):
        result = self.finite_automaton.check_string("")
        self.assertFalse(result)
```

#### Test Analysis: Grammar Tests

The `TestGrammar` class contains four test cases that verify different aspects of the `Grammar` class's functionality:

1. `test_generate_string_contains_only_terminals`: Ensures that generated strings contain only terminal symbols, which is a fundamental requirement for string generation from a grammar.
2. `test_generate_multiple_strings`: Verifies that the `generate_strings` method correctly generates the requested number of strings.
3. `test_generated_strings_are_not_empty`: Checks that generated strings are not empty, which could happen if the grammar contained problematic production rules.
4. `test_productions_are_followed`: Another check that all characters in the generated string are terminals, ensuring that the production rules are correctly followed.

These tests provide good coverage of the basic functionality of the `Grammar` class, ensuring that it generates valid strings according to the defined grammar.

#### Test Analysis: Finite Automaton Tests

The `TestFiniteAutomaton` class contains three test cases that verify the string validation functionality of the `FiniteAutomaton` class:

1. `test_check_valid_string`: Ensures that a known valid string is correctly accepted by the automaton.
2. `test_check_invalid_string`: Verifies that a known invalid string is correctly rejected by the automaton.
3. `test_empty_string`: Checks that an empty string is rejected by the automaton, which is correct for this particular grammar.

These tests provide basic validation of the `FiniteAutomaton` class's functionality, ensuring that it correctly distinguishes between valid and invalid strings.

## Results and Analysis

### Grammar String Generation

The `Grammar` class successfully generates valid strings according to the defined grammar. Here are 5 examples of generated strings:

1. `cbccfem`
2. `ce`
3. `cfcbne`
4. `cenm`
5. `cbncse`

Each of these strings follows the production rules defined in the grammar, starting from the start symbol 'S' and replacing non-terminals until only terminals remain.

#### Derivation Analysis

Let's analyze the derivation of one of these strings, `cbccfem`:

1. Start with S: S
2. Apply S → cI: cI
3. Apply I → bJ: cbJ
4. Apply J → cS: cbcS
5. Apply S → cI: cbccI
6. Apply I → fI: cbccfI
7. Apply I → e: cbccfe
8. Apply I → eK: cbccfeK
9. Apply K → m: cbccfem

This derivation demonstrates how the string generation algorithm works, repeatedly applying production rules until a string consisting entirely of terminal symbols is obtained.

### Finite Automaton String Validation

The `FiniteAutomaton` class correctly validates strings against the grammar:

- Valid strings like "cbccfem" are accepted
- Invalid strings like "cbccf" are rejected
- Empty strings are rejected

#### Validation Analysis

Let's analyze how the `check_string` method validates the string "cbccfem":

1. Start at state S with index 0
2. Read 'c', transition to state I, index 1
3. Read 'b', transition to state J, index 2
4. Read 'c', transition to state S, index 3
5. Read 'c', transition to state I, index 4
6. Read 'f', transition to state I, index 5
7. Read 'e', transition to state '' (empty string), which maps to final state F, index 6
8. Read 'm', transition is not defined from F, so this path is rejected

However, there's an alternative path:
1. Start at state S with index 0
2. Read 'c', transition to state I, index 1
3. Read 'b', transition to state J, index 2
4. Read 'c', transition to state S, index 3
5. Read 'c', transition to state I, index 4
6. Read 'f', transition to state I, index 5
7. Read 'e', transition to state K, index 6
8. Read 'm', transition to state '' (empty string), which maps to final state F, index 7
9. End of string reached, current state is F (a final state), so the string is accepted

### Transition Visualization

The finite automaton's transitions can be visualized as follows:

```
State S ---(c)---> ['I']
State I ---(b)---> ['J']
State I ---(f)---> ['I']
State I ---(e)---> ['', 'K']
State J ---(n)---> ['J']
State J ---(c)---> ['S']
State K ---(n)---> ['K']
State K ---(m)---> ['']
```

This visualization shows the state transitions for each input symbol. For example, from state S, reading 'c' leads to state I. From state I, reading 'e' can lead to either an empty state (which maps to the final state F) or state K, demonstrating the non-deterministic nature of the automaton.

## Equivalence of Grammar and Automaton

The implementation demonstrates the fundamental equivalence between regular grammars and finite automata. The `FiniteAutomaton` class, constructed from the `Grammar` class, correctly recognizes the same language as the grammar generates.

This equivalence is shown by:

1. Successfully converting the grammar to an automaton using the `__build_transitions` method
2. Validating that strings generated by the grammar are accepted by the automaton
3. Ensuring that invalid strings are rejected by the automaton

This practical demonstration reinforces the theoretical concept that regular grammars and finite automata have equivalent expressive power.

## Execution Screenshots

![Grammar String Generation](https://placeholder-image.com/grammar_generation.png)
![Finite Automaton Validation](https://placeholder-image.com/automaton_validation.png)

## Conclusions

This laboratory work successfully implemented and tested a formal grammar and its corresponding finite automaton. The key achievements include:

1. Creating a `Grammar` class capable of generating valid strings according to defined production rules
2. Implementing a `FiniteAutomaton` class that can validate strings against the grammar
3. Converting a grammar to a finite automaton through a well-defined algorithm
4. Testing the functionality of both classes through comprehensive unit tests

The implementation demonstrates the fundamental relationship between formal grammars and finite automata, providing a solid foundation for further exploration of more complex formal language concepts in future laboratory works.

### Limitations and Future Work

While the current implementation successfully demonstrates the basic concepts, there are several limitations and opportunities for future enhancements:

1. The grammar implementation is limited to right-linear regular grammars. Supporting left-linear grammars would provide a more complete implementation.
2. The automaton implementation is non-deterministic. Adding support for converting to a deterministic finite automaton would be a valuable extension.
3. The string generation algorithm uses a breadth-first approach, which may not be optimal for all grammars. Implementing alternative algorithms, such as depth-first generation, could be beneficial.

These limitations provide opportunities for future work, building on the solid foundation established in this laboratory assignment.

### Learning Outcomes

Through this laboratory work, several key learning outcomes were achieved:

1. Deepened understanding of formal languages, regular grammars, and finite automata
2. Gained practical experience in implementing theoretical concepts
3. Developed skills in testing and validating algorithm implementations
4. Enhanced ability to analyze and reason about formal language concepts

These outcomes provide a solid foundation for future studies in formal languages and automata theory, which are essential for understanding compiler design, parsing algorithms, and formal verification techniques.